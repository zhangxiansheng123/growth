#### 1、 描述一下jvm内存模型，以及这些空间的存放的内容 ?

首先JVM由类装载器、运行时数据区、执行引擎、本地方法接口和本地方法库组成。

* 类加载器：见第2题

* 运行时数据区主要包括：

  1. 方法区：存储已经被虚拟机加载的类元数据信息（元空间）（在方法区中,存储了每个类的信息(包括类的名称,方法信息,字段信息)、静态变量、常量以及编译器编译后的代码等。 在Class文件中除了类的字段、方法、接口等描述信息外,还有一项信息是常量池,用来存储编译期间生成的字面量和符号引用。在方法区中有一个非常重要的部分就是运行时常量池,它是每一个类或接口的常量池的运行时表示形式,在类和接口被加载到JVM后,对应的运行时常量池就被创建出来。当然并非只有Class文件常量池中的内容才能进入运行时常量池,在运行期间也可将新的常量放入运行时常量池中,比如String的intern方法。）从JDK8开始，方法区被元数据区替代了。（**静态变量+常量+类信息(构造方法/接口定义)+运行时常量池**存在方法区中，但是**实例变量存在堆内存**中,和方法区无关）

  2. 堆：存放对象实例，几乎所用的对象实例都在这里分配内存

  3. Java虚拟机栈：虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧，栈帧中主要保存3 类数据：本地变量（输入参数和输出参数以及方法内的变量。）、栈操作（记录出栈、入栈的操作。）、栈帧数据（包括类文件、方法等）（**8种基本类型的变量+对象的引用变量+实例方法**都是在函数的栈内存中分配。）

  4. 程序计数器：每个线程都有一个程序计数器，是**线程私有的**，就是一个指针，指向方法区中的方法字节码（**用来存储指向下一条指令的地址**，即 将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。

  5. 本地方法栈：Native Method Stack中登记native方法，在Execution Engine 执行时通过Native Interface加载本地方法库。

- 执行引擎Execution Engine：如果想让一个Java程序运行起来，执行引擎Execution Engine将字节码指令解释/编译为对应平台上的本地机器指令才可以，提交操作系统执行。（通常java跨平台是因为jvm本质是执行引擎）
- 本地接口Native Interface：主要是为了融合不同编程语言为Java所用（主要是C/C++），于是在内存开辟了一块区域处理标记为native的代码，具体做法是在Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies.
- 本地方法库：

#### 2、JVM类加载原理?

类加载器负责加载class文件，class 文件在文件开头由特定的文件标识，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。

类加载器分为四种：前三种为Java虚拟机自带的加载器

* 启动类加载器（BootStrap）C++：负责加载$JAVA_HOME中的jre/lib/rt.jar里所有的class,由C++实现，不是ClassLoader的子类。

* 扩展类加载器（Extension）Java：负责加载java平台中除了rt.jar之外的**扩展功能**的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包

* 应用程序加载器（AppClassLoader）Java：
* 用户自定义加载器：继承Java.lang.ClassLoader后，用户可以定制类的加载方式。

类加载器工作过程（双亲委派模式）

* 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
* 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
* 如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载。
* 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载
* 如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。

双亲委派的好处：

* 每一个类都只会被加载一次，避免了重复加载。
* 每一个类都会被尽可能的加载（从引导类加载器往下，每个加载器都可能会根据优先次序尝试 加载它）
* 有效避免了某些恶意类的加载，防止内存中出现多份字节码。（比如自定义了Java.lang.Object类，一般而言在双亲委派模型 下会加载系统的Object类而不是自定义的Object类）

#### 3、类初始化过程？

#### 4、classloader这个类做了什么？

#### 5、JVM垃圾判定算法（对象已死）,变量什么情况下会被垃圾回收?

* 引用计数法(Reference-Counting) 

  * 引用计数算法是通过判断对象的**引用数量**来决定对象是否可以被回收。

  * 优点：简单，高效，现在的objective-c、python等用的就是这种算法。

  * 缺点：引用和去引用伴随着加减算法，影响性能

  * 很难处理循环引用，相互引用的两个对象则无法释放，可能产生内存泄漏（两个对象相互引用）。

    **因此目前主流的Java虚拟机都摒弃掉了这种算法**。

* 可达性分析算法（根搜索算法）

  * 这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。
  * 在Java语言中，可以作为GC Roots的对象包括下面几种：
    * 虚拟机栈（栈帧中的本地变量表）中的引用对象。
    * 方法区中的类静态属性引用的对象。
    * 方法区中的常量引用的对象。 
    * 本地方法栈中JNI（Native方法）的引用对象

**真正标记以为对象为可回收状态至少要标记两次。**

#### 6、什么是OOM ？什么是StackOverflowError？有哪些方法分析？

* OOM(OutOfMemoryError)出现在养老区和永久区，若养老区执行了两次Full GC之后发现依然无法进行对象的保存，就会产生OOM异常,如果出现<font color='red'>java.lang.OutOfMemoryError: Java heap space</font>异常，说明Java虚拟机的堆内存不够。原因有二：**（1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。****（2）**代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。**	如果出现<font color='red'>java.lang.OutOfMemoryError: PermGen space</font>，**可能是Java虚拟机对永久代Perm内存设置不够、程序启动加载大量的第三方jar包。tomcat中运行了太多的项目、或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。** Jdk1.6及之前： 有永久代，常量池1.6在方法区，Jdk1.7： 有永久代，但已经逐步“去永久代”，常量池1.7在堆。**Jdk1.8及之后： 无永久代，常量池1.8在元空间（Metaspace）**
* StackOverflowError一般出现在方法的递归调用中。
* 分析方法：在Eclipse中MAT工具的使用，在idea中修改配置参数生成dump文件后缀为**.hprof，使用jdk自带的文件解读工具jvisualvm.exe分析

* 内存快照抓取和MAT分析DUMP文件知道吗？

#### 7、Java四种引用?

* 强：new User()，强引用只要存在引用就不会被垃圾回收器回收。
* 软：通过SoftReference初始化一个软引用，一旦将要发生OOM都会被垃圾回收器回收。高速缓存
* 弱：通过WeakReference初始化，一旦发生GC就会被垃圾回收器回收。
* PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

#### 8、聊一下堆的分区及特点、GC过程、常用的GC算法有哪些，分别用在什么时候，GC收集器有哪些，你们项目使用的垃圾回收器？

[新生代垃圾回收机制](https://blog.csdn.net/qq_40662405/article/details/114783644)

堆中的区域划分，堆里面的分区：Eden，survival from to，老年代：

* 新生区是对象的诞生、成长、消亡的区域，一个对象在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分： 伊甸区（Eden space）和幸存者区（Survivor pace） ，所有的对象都是在伊甸区被new出来的。幸存区有两个： 0区（Survivor 0 space）和1区（Survivor 1 space）。
* 老年代：经历多次GC仍然存在的对象（默认是15次），老年代的对象比较稳定，不会频繁的GC
* 永久代：永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。

GC过程：

* 新生代的垃圾回收机制什么时候触发：eden满了会发生minorGC

* 老年代的垃圾回收机制什么时候触发，自动触发的阈值是多少：

  * 当老年代没有足够空间存放对象时，会触发一次FullGC，fullGC之前伴随着一次monorGC
  * 一般是两个原因引起的，要么是老年代内存过小，要么是老年代连续内存过小，存放不下对象了，如果元空间区域的内存达到了所设定的阈值-XX:MetaspaceSize=，也会触发FullGC

常用的GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方

* 复制算法：把内存平均分成两份，只使用其中一份，这一份内存满了之后，把存活对象copy到另一半内存。清空满了的那一半内存。
  * 优点：对象存活率不高的情况下简单高效  不会产生内存碎片
  * 缺点：浪费一般内存空间   对象存活率较高的情况下，所有对象都要copy，并重置指针，效率不高
  * 新生代（对象存活率不高，不会超过10%）使用的垃圾回收算法就是复制算法。
* 标记清除算法：分成两个阶段:
  * 标记阶段：标记出需要回收的对象，使用的标记算法均为**可达性分析算法**。
  * 清除阶段：清除死亡的对象，回收被标记的对象。
  * 缺点：经过两次遍历，效率不高，产生大量的内存碎片
* 标记整理（压缩算法）：标记-整理法是标记-清除法的一个改进版。同样，在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是通过**所有存活对像都向一端移动，然后直接清除边界以外的内存。**
  * 优点：避免了一半内存的浪费，避免了内存碎片的产生
  * 缺点：两次遍历效率不高，移动对象并重置指针，效率更低。

**老年代一般是由标记清除或者是标记清除与标记整理的混合实现。**

* Minor GC与Full GC分别在什么时候发生。

* GC垃圾回收主要有四大算法：（怎么找到已死对象并清除？）

  * 复制算法(Copying)

  * 标记清除(Mark-Sweep)

  * 标记压缩(Mark-Compact)，又称标记整理

  * 分代收集算法(Generational-Collection)

    * 分代回收算法：其实不是一种真正意义上的算法。

      * 内存利用率：标记整理算法  >  标记清除算法 > 复制算法

      * 内存连续性：标记整理算法 = 复制算法 > 标记清除算法

      * 效率：对象存活率不高：复制算法  > 标记清除算法 > 标记整理算法

        ​			对象存活率高：标记清除算法 > 复制算法 > 标记整理算法

      * 新生代对象存活率不高：选择复制算法

      * 老年代对象存活率较高：选择标记清除算法 标记整理算法

* 垃圾回收器有哪些 都有那些算法来实现项目中用的垃圾回收器是什么

* 垃圾回收器：是垃圾算法的具体实现

  * serial（复制算法）/serial old（标记压缩）：串行的垃圾回收器。客户端程序选择
  * parallel/parallel old（标记压缩）：服务器端项目
  * CMS（标记清除算法）：可预测的停顿时间
    * 初始标记阶段：只标记出GCRoot对象或者GCRoot对象直达的对象，会导致STW
    * 并发标记阶段：标记出所有存活对象，不会产生STW
    * 重新标记阶段：标记出上一个阶段没有标记到的对象。会导致STW
    * 清除阶段：清除垃圾对象，不会产生STW
    * 优点：高效，低停顿高吞吐量
    * 缺点：可能会产生大量的内存碎片，在运行时间比较久之后，服务会越来越慢
  * G1：类似于CMS
    * 大小相等的区块组成，优先回收垃圾率较高的区块

#### 7、你有JVM调优经验吗，jvm你怎么优化的，JVM 的常用参数调优你知道哪些？

```java
答：有，根据我自己的理解JVM调优不是一上来就进行各种JVM参数优化；
1、首先我们会排查是不是关系型数据库遇到了瓶颈，这个过程会分析自己建的索引是否合理、是否需要引入缓存(分布式缓存)、(是否需要分库分表等)。
2、然后我们会考虑是不是需要扩容（横向和纵向都会考虑），这个过程中会去排查是不是系统压力过大，或者是系统的硬件能力不足导致的系统频繁出现问题。
3、其实出现问题很可能是代码的问题，这就需要从代码层面进行排查和优化，扩容虽然能解决大部分问题，可是都需要花钱的，这个过程我们回去排查自己写的代码是否存在资源浪费的问题，又或者在逻辑上存在可以优化的地方，比如通过并行的方式处理某些请求。
4、再接着，JVM层面上进行优化，这个过程我们会去观察JVM是否存在多次GC的问题
5、最后，网络和操作系统层面排查，这个过程查看内存/cpu/网络/硬盘读写指标是否正常等等。
在我的理解下，调优JVM其实就是理解JVM内存结构以及各种垃圾收集器前提下，结合自己现有的业务来调整参数，对服务器性能进行压榨，使应用稳定运行。调优主要参考指标有吞吐量、响应时间（停顿时间）、和垃圾收集频率，基于这些指标我们可能需要调整：
1、内存区域大小以及相关策略（比如整块堆内存占多少、新生代占多少、老年代占多少、Survivor占多少、晋升老年代的条件等，主要参数-Xms:设置堆的初始值、-Xmx:设置堆的最大值、-Xmn:表示年轻代的大小、-XX：SurvivorRatio:伊甸区和幸存区的比例等等，按照经验来说IO密集型可以稍微把年轻代空间加大点，因为大多数对象在年轻代就会灭亡，内存计算密集型的可以稍微把老年代空间加大点，对象存活时间会长些）
2、垃圾回收器（选择合适的垃圾回收器，以及各个垃圾回收器的各种调优参数，比如-XX:+UseG1GC:指定JVM使用的垃圾回收器为G1、-XX：MaxGCPauseMills:设置目标停顿时间、-XX：InitiatingHeapOccupancyPercent:当整个堆内存达到一定比例全局并发标记阶段就会被启动等等）
一般来说使用JVM默认的参数就能解决大多数问题，一般是遇到问题进行调优的，遇到问题需要利用一些工具进行排查：
1、top命令观察到问题：内存不断增长CPU占用率居高不下
2、top -Hp观察进程中的线程，哪个线程CPU和内存占比高
3、jps定位具体的java进程，jstack定位线程情况，重点关注WAITING、BLOCKED
4、jstat -gc 动态观察GC情况
5、jmap -histo 进程号 | head -20，查找有多少对象产生（定位占内存多的对象），也可以用jmap将jvm内存信息dump到文件，使用MAT或者JvisualVM等工具分析，不过dump过程不能轻易去操作，过程会造成服务卡顿，影响使用。
也可以使用阿里的Arthas工具，里面也涵盖了一些命令，有助于分析。
我曾经遇到的JVM调优问题：
1、当时做hbase数据迁移的时候，同步数据很慢，把垃圾回收器改成了G1，停顿时间设置了好像是2ms后，速度有明显的提升。
2、当时有一个应用往磁盘写入数据量巨大，动不动就OOM，调整了JVM堆的大小，由于偏向于IO操作，把新生代调大了，问题得到了解决。
3、还有一个问题当时我们的系统频繁FullGC，服务勉强能够使用，每次在晚上都重启一下服务，最后加内存并更换了G1，问题得到了解决。

调优参数：
* -Xms :初始堆大小。只要启动，就占用的堆大小，默认是内存的1/64
* -Xmx:最大堆大小。默认是内存的1/4
* -Xmn:新生区堆大小
* -XX:+PrintGCDetails:输出详细的GC处理日志
* 命令：java -Xms20m -Xmx50m xx.class
  jps -l：查看服务器的所有java进程
  jinfo -flags 进程号：查看进程的jvm参数设置
  jstat -gc 进程号：查看jvm结构，GC情况
```

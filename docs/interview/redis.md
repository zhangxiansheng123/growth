1. redis的数据类型？		

   ```
   常用的有五大数据类型： key---> value(string、list、set、hash、zset)
   1、 String类型是最基本的数据类型，一个key对应一个value，是二进制安全的意味着String可以包含任意数据，比如图片或者序列化对象，一个redis的字符串的value最多可以使512M
   2、 list,单键多值，是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）和尾部（右边）。它的底层实际上是个双向链表，对两端的操作性能很高，通过索引操作中间的节点性能会较差。
   3、 set对外提供的功能与list类似是一个列表的功能，不同之处是set是可以自动排重的。当存储列表数据又不想有重复数据时可以选用。并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)
   4、 hash 是一个键值对集合，hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。eg:   hset <key>  <field>  <value>    	
   5、 zset有序集合，与set相似，是一个没有重复元素的字符串集合，不同之处是有序集合中的每个成员都关联了一个得分score用来排序集合中的成员，评分可以重复。
   ```

2. 说一下你在项目中redis的应用场景？

   ```
   a、数据访问频繁，写的频率非常少，5大value类型
   b、基本上就是缓存，缩短业务流程，进而减少响应时间，提高并发能力，保护数据库！！
   c、为的就是服务无状态 ，延伸搜索，看自己项目有哪些数据结构或对象，在单机里需要单机锁，在多机需要分布式锁，抽出来放入Redis中
   d、无锁化
   ```

3. redis是单线程还是多线程？redis为什么快？

   ```
   a、redis是单线程的，redis是基于内存操作，cpu不是redis性能瓶颈，而是根据机器的内存和网络带宽，高性能的服务器并不都是多线程的，因为多线程cpu上下文切换会耗时，redis将所有的数据放入内存中，所以单线程操作效率是最高的，多线程操作对于内存系统来说会有cpu上下文切换耗时（读写速度：cpu>内存>硬盘）
   b、6.x版本出现了IO多线程,无论什么版本，工作线程就一个,使用上来说没有变化,IO多线程的好处是把输入/输出放到更多的线程去并行，好处是：执行时间缩短，更快，更好的压榨系统及硬件的资源。
   ```

4. redis存在线程安全的问题吗？为什么？

   ```
   redis是单线程的，redis可以保障内部串行，外界和业务使用时，要自行保障顺序。
   ```

5. redis和memcached的区别？

   ```
   1、redis支持多种数据类型，支持持久化，value最大值512M,redis是单线程+io多路复用实现
   2、memcached是串行+多线程+锁的方式，只支持String（value），不支持持久化，数据全存在内存，断电消失。
   ```

6. 读的并发问题，缓存穿透、缓存击穿、缓存雪崩,有遇到过吗？怎么避免？

   ```
   1、缓存穿透：大量的请求同时访问不存在的数据，就会越过缓存到达数据库，导致数据库宕机。（比如说：根据产品id获取产品详情的接口，那么我用一个id=-1去请求，那肯定是获取不到任何数据的。一般这样的情况有可能服务器遭到了恶意攻击。）
   解决方案：数据即使为null也缓存，（缓存key-->null）、使用布隆过滤器，也可以在永辉请求接口层增加一些校验，例如：用户鉴权校验、参数传值校验等不合法的参数请求直接返回。
   2、缓存击穿：一个热点key过期，此时大量请求同时访问该数据，就会直达数据库，导致数据库宕机。
   解决方案：设置这个key永不过期，加JVM锁或者分布式锁，缓存预热时尽量全面覆盖热点key，可以服务器熔断、降级，限制每个用户的访问次数，并且如果获取不到数据即返回一个固定的推荐页面。
   3、缓存雪崩：缓存时间相同导致大量的缓存数据同时过期，此时大量请求进来就会直达数据库，导致数据库宕机。
   解决方案：给缓存时间设置一个随机值，也可以热点数据永不过期，如果有数据更新直接更新redis即可。
   notes:当然这几个也可能是缓存预热时没有缓存到这些数据，所以缓存预热时应尽可能覆盖这些热点数据。
   ```

7. 缓存如何回收的？

   ```
   1、后台有轮询机制，分段分批的删除那些过期的key
   2、请求的时候判断是否已经过期了
   notes：尽量吧内存无用空间回收回来
   ```

8. redis是怎么删除过期key的，过期键删除策略？

   ```
   1、定时删除:在设置键的过期时间的同时，创建一个定时器 timer). 让定时器在键
   的过期时间来临时，立即执行对键的删除操作。
   2、惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是
   否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。
   3、定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至
   于要删除多少过期键，以及要检查多少个数据库，则由算法决定。
   ```

9. redis如何淘汰的，淘汰策略？

   ```
   1、noeviction：默认策略，不淘汰，如果内存已经满了，添加数据报错
   2、volatile-lru:根据近似lru算法（最近最少使用）进行淘汰，在设置了过期时间的所有键中，选取最近最少使用的数据抛弃，但不会丢弃没有设置过期时间的key
   3、volatile-ttl：比较有过期时间的key的寿命，寿命短的先淘汰
   4、volatile-random：从设置了过期时间的key中随机选择key进行淘汰
   5、allkeys-lru：在所有键中，选取最近最少使用的数据抛弃
   6、allkeys-random：和volatile-random相比，淘汰范围从所有设置了过期时间的key，扩展到了所有的key（包含没有设置过期时间的key）。
   ```

10. 如何进行缓存预热？

   ```
   1、提前把数据放入redis（你知道哪些是热数据吗？肯定不知道，可能会造成很多数据没有缓存命中）
   2、开发逻辑上也要规避差集（没有进行缓存的）。
   3、我遇到过缓存预热没有覆盖全面引起的缓存穿透、缓存击穿、缓存雪崩，实施这几个问题的解决方案即可解决。
   ```

11. 数据库与缓存不一致如何解决？（缓存写的一致性问题）

    ```
    1、双写模式：不管先写谁都可以出现数据不一致：
      先写mysql，再写redis。后续代码出现异常，mysql会回滚，redis不会回滚，导致数据不一致
      先写redis，再写mysql。写redis成功，写mysql失败，数据不一致。
    2、失效模式：
      先删redis还是后删redis都会出现，事务还未提交，另一个线程读取数据，重新把旧数据放入缓存，此时再去提交，就会出现数据不一致。
    3、双删模式
      先删redis
      再写mysql
      再异步删除redis
    4、以上方案其实都会有问题，真的要落地就使用canal中间件吧。
    ```

12. 简述一下主从不一致性问题？（不太明白）

    ```
    1，redis的确默认是弱一致性，异步的同步
    2，锁不能用主从(单实例/分片集群/redlock)==>redisson
    3，在配置中提供了必须有多少个Client连接能同步，你可以配置同步因子，趋向于强制一性
    4，wait 2 0  小心
    5，34点就有点违背redis的初衷了
    ```

13. 描述一下redis持久化原理？

    ```
    当前线程阻塞服务 不聊
    异步后台进程完成持久
    fork  +  cow
    ```

14. redis有哪些持久化机制？

    ```
    Redis支持RDB和AOF两种持久化机制，持久化功能能有效地避免因进程退出造成的数据丢失问题，当下次重启时利用之前的持久化文件即可实现数据恢复。
    	RDB持久化：RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发（save，bgsave）和自动触发。（可能丢失最后一次保存）
    	 save 触发：该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。执行完成时候如果存在老的RDB文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。
    	 bgsave触发方式：具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。
    	 自动触发是由我们的配置文件来完成的：
    	 save 900 1  //在900秒之后，如果至少有1个key发生变化，则dump内存快照。
    	 save 300 10
    	 save 60 10000
       AOF做增量备份，每一个写命令都通过write函数追加到appendonly.aof 中。AOF也有三种触发机制：
        每修改同步always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好
        每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失
        不同no：从不同步
        优点：AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。
        缺点：对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大，AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的，以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。
       RDB+AOF混合持久化：
        4.x 新增更有性能模式：把重写方式换成直接RDB放到aof文件的头部，比2.1的方法快了，再追加日志
    ```

15. redis也打不住了万级流量会打到DB上，该怎么处理？

    ```
    见缓存穿透、缓存击穿、缓存雪崩
    ```

16. redis中的事务三条指令是什么，第三天指令到达后执行失败了怎么处理？

    ```
    multi开启事务
    exec执行事务
    discard放弃事务
    事务的执行是原子的，执行失败就是执行失败的，其他指令继续执行，没有回滚
    ```

17. 为什么使用setnx? redis实现分布式锁的指令？

    ```
    1、好东西，天然原子性（不存在的情况下完成创建）
    2、如果要做分布式锁，就要用set k v nx ex （不存在，过期时间，避免死锁）
    ```

18. redis分布式锁实现，理论：

19. 你们为什么redis和mysql都存储了数据，存储到mysql的意义是什么？

    ```
    Redis基于内存，读写速度快，也可做持久化，但是内存空间有限，当数据量超过内存空间时，需扩充内存，而内存成本较高；
    基于磁盘，读写速度没有Redis快，但是不受空间容量限制，性价比高；
    场景：多数时候是MySQL（主）+Redis（辅），MySQL做为主存储，Redis用于缓存，加快访问速度。需要高性能的地方使用Redis，不需要高性能的地方使用MySQL。一个优秀的网站不同模块一定是有对性能不同的要求的，性能要求高的模块我们使用redis(拿空间换速度)，其他模块使用性价比更高的mysql储存。
    ```

20. redis集群主从模式

    ```
    主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，主机支持数据的写入和读取（以写为主）等各项操作，而从机则只支持与主机数据的同步和读取。
    三种主从模式：
     一主二仆：每次从机联通后，都会给主机发送sync(同步)指令，主机立刻进行存盘操作，发送RDB文件给从机，从机收到RDB文件后覆盖自己的RDB文件，进行全盘加载，之后每次主机的写操作，都会立刻发送给从机，从机执行相同的命令。（主机宕机后从机原地待命）
     薪火相传：上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。使用slave of ip sort  风险是一旦某个slave宕机，后面的slave都没法备份, 主机挂了，从机还是从机，无法写数据了 ,去掉从服务器身份 slaveof no one
     反客为主：执行slave of no one 主机挂了，选举一个从机当主机。（哨兵是反客为主的自动版不用手动执行命令）
    优点：读写分离，性能扩展，容灾快速恢复
    ```

21. 你的redis版本多少（4.0或者6.0），集群是主从还是哨兵，哨兵是从什么版本出现的？(待理解优化成自己说法)

    ```
    sentinel(哨兵)是用于监控redis集群中Master状态的工具，是Redis 的高可用性解决方案，sentinel哨兵模式已经被集成在redis2.4之后的版本中。
    哨兵模式工作方式：
      每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他Sentinel实例发送一个PING命令 ，用来心跳检测。
      如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值，则这个实例会被 Sentinel 标记为主观下线。 
      如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。 
      当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 
      在一般情况下， 每个 Sentinel 会以每10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 
      当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 （该命令第一个是用来发现slave节点,第二个是确定主从关系.）
      若没有足够数量的 Sentinel 同意Master 已经下线， Master 的客观下线状态就会被移除。 
      若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。
      当master被确认下线后，在从服务中挑选一个作为主服务，选择优先级靠前的，偏移量最大的，runid最小的从服务作为主服务。挑选出新的主服务sentinel向原主服务的从服务，发送slaveof新主服务的命令，复制新master，当已经下线的服务重新上线时，sentinel会向其发送slave of 成为新主的从。（优先级在redis.conf中默认：slave-priority 100，值越小优先级越高，偏移量是指获得原主机数据最全的，每个redis实例启动后都会随机生成一个40位的runid）
    ```

**NOTES**：面试题只有变成自己的话叙述出来才行，不然就是白搞。

